# CSS3+H5

 [CSS3.0 帮助文档.chm](CSS3.0 帮助文档.chm) 

注意：CSS3不支持IE6，7，8。兼容性

### flex弹性布局：

<参考资料：http://www.runoob.com/w3cnote/flex-grammar.html>

**兼容性问题:**Webkit内核的浏览器，必须加上-webkit前缀。

```css
.box{
  display: -webkit-flex; /* Safari */
  display: flex;
}
```

**注意**：设为Flex布局以后，**子元素**的float、clear和vertical-align属性将失效。

##### 1.基本概念

采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。

主轴：橫                  交叉轴：竖

##### **2.容器具有的属性**

###### **flex-direction**

**决定主轴的方向（项目的排列方向）**

- row（默认值）：主轴为水平方向，起点在左端。
- row-reverse：主轴为水平方向，起点在右端。
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿。

###### **flex-wrap**

**定义如果一条轴线排不下，如何换行。**

- nowrap（默认值） ：不换行（**会把项目压缩**）
-  wrap  ：换行
- wrap-reverse： 换行，第一行在下面

###### **flex-flow**

**属性和flex-wrap属性的简写形式**

```css
.box {
  flex-flow: flex-direction flex-wrap;
}
```

###### **justify-content**

**项目在主轴上的对齐方式。**

- flex-start（默认值）：左对齐
- flex-end：右对齐
- center： 居中
- space-between：两端对齐，项目之间的间隔都相等。
- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

###### **align-items**

**定义项目在交叉轴上如何对齐**

- flex-start：交叉轴的起点对齐。
- flex-end：交叉轴的终点对齐。
- center：交叉轴的中点对齐。
- baseline: 项目的第一行文字的基线对齐。
- stretch（**默认值**）：如果项目未设置高度或设为auto，将占满整个容器的高度。

###### **align-conten**

定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

##### 3.项目具有的属性****

1. order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。

2. flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

3. flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

4. flex-basis：

   定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。

   设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

5. **flex：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。**

6. align-self：允许单个项目有与其他项目不一样的对齐方式，**可覆盖align-items属性**。默认值为**auto**，**表示继承父元素的align-items属性**，如果没有父元素，则等同于stretc

   该属性可取6个值，除了auto，其他都与align-items属性完全一致。

   ``` css
   .item {
     align-self: auto | flex-start | flex-end | center | baseline | stretch;
   }
   ```

### transtion：过渡

语法格式:

```
transition: 要过渡的属性  花费时间  运动曲线  何时开始;
```

| 属性                       | 描述                                         | CSS  |
| :------------------------- | -------------------------------------------- | ---- |
| transition                 | 简写属性，用于在一个属性中设置四个过渡属性。 | 3    |
| transition-property        | 规定应用过渡的 CSS 属性的名称。              | 3    |
| transition-duration        | 定义过渡效果花费的时间。默认是 0。           | 3    |
| transition-timing-function | 规定过渡效果的时间曲线。默认是 "ease"。      | 3    |
| transition-delay           | 规定过渡效果何时开始。默认是 0。             | 3    |

运动曲线示意图：

![transition](C:\Users\92530\Desktop\面试复习\images\transition.png)

```css
img {
  width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%;
  transition:transform 0.5s ease-in 0s;
}
img:hover {
  transform:rotate(180deg);
}
```

## 响应式开发相关

布局方式：固定宽度布局  	流式布局栅	 格化布局   响应式布局（主流）

响应式布局：缺点。代码冗余，性能拥挤，但是开发效率高

适用于官网博客，新闻资讯等内容性网站

### @media 媒体查询

针对不同媒体类型（或者说屏幕宽度）自适应采用不同的样式规则。当你重置浏览器大小的过程中，页面会根据浏览器的宽度和高度重新渲染页面。

用于响应式布局，根据设备屏幕不同

常用区间值

| 超小屏幕                   | (移动设备)xs | w<768px     |
| -------------------------- | ------------ | ----------- |
| 小屏设备（平板）**sm**     | 768px-992px  | 768<=w<992  |
| 中等屏幕（电脑1024）**md** | 992px-1200px | 992=<w<1200 |
| 宽屏设备**lg**             | 1200px以上   | w>=1200     |

使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。

@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。

当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面

向上兼容：如果设置了小的，小的会传递到大的

向下覆盖：宽度大的覆盖前面宽度更小的

##### 书写顺序建议

**如果判断最小值：从小到大写**

**如果判断最大值：从大到小写**

1. 媒体查询的基本实现方式：常用属性设置: http://www.runoob.com/cssref/css3-pr-mediaquery.html

a)       CSS 语法

```css
@media mediatype and|not|only (media feature) {
   CSS-Code;
}
```

1、and 可以将多个媒体特性连接到一起，相当于“且”的意思。

2、not 排除某个媒体类型，相当于“非”的意思，可以省略。

3、only指定某个特定的媒体类型，可以省略。

```html
<!--你也可以针对不同的媒体使用不同 stylesheets :  -->
<link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css">
```

b)       媒体类型

| 值     | 描述                                 |
| ------ | ------------------------------------ |
| all    | 用于所有设备                         |
| print  | 用于打印机和打印预览                 |
| screen | 用于电脑屏幕，平板电脑，智能手机等。 |
| speech | 应用于屏幕阅读器等发声设备           |

c)           媒体功能                       

| 值                | 描述                                   |
| ----------------- | -------------------------------------- |
| device-width      | 定义输出设备的屏幕可见宽度。           |
| max-device-height | 定义输出设备的屏幕可见的最大高度。     |
| max-device-width  | 定义输出设备的屏幕最大可见宽度。       |
| min-device-width  | 定义输出设备的屏幕最小可见宽度。       |
| min-device-height | 定义输出设备的屏幕的最小可见高度。     |
| max-height        | 定义输出设备中的页面最大可见区域高度。 |
| max-width         | 定义输出设备中的页面最大可见区域宽度。 |
| min-height        | 定义输出设备中的页面最小可见区域高度。 |
| min-width         | 定义输出设备中的页面最小可见区域宽度。 |
| device-height     | 描述定义输出设备的屏幕可见高度。       |



## bootstrap框架

- col- 针对所有设备
- .col-sm- 平板 - 屏幕宽度等于或大于 576px
- .col-md- 桌面显示器 - 屏幕宽度等于或大于 768px)
- .col-lg- 大桌面显示器 - 屏幕宽度等于或大于 992px)
- .col-xl- 超大桌面显示器 - 屏幕宽度等于或大于 1200px)

boostrap是 向上兼容的

#### 栅格原理（col-xs-12）：

- “行（row）”必须包含在 `.container` （固定宽度）或 `.container-fluid` （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。
- 通过“行（row）”在水平方向创建一组“列（column）”。
- 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。
- 类似 `.row` 和 `.col-xs-4` 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。
- 通过为“列（column）”设置 `padding` 属性，从而创建列与列之间的间隔（gutter）。通过为 `.row` 元素设置负值 `margin` 从而抵消掉为 `.container` 元素设置的 `padding`，也就间接为“行（row）”所包含的“列（column）”抵消掉了`padding`。
- 负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。
- 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 `.col-xs-4` 来创建。
- 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。
- 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 `.col-md-*`栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 `.col-lg-*`不存在， 也影响大屏幕设备。

栅格原理是本质是设置百分比，即流式布局

offset：通过margin，因此会影响其他元素导致换行

###### 列排序

push：通过定位，可能会重叠

pull：通过定位，可能会出现

hidden-xs：在某一屏幕隐藏



![col-xs-12](C:\Users\92530\Desktop\interview\面试复习\images\col-xs-12.png)





## less

LESS 是动态的样式表语言，通过简洁明了的语法定义，使编写 CSS 的工作变得非常简单，本质上，LESS 包含一套自定义的语法及一个解析器。

#### 安装

1、安装Nodejs环境 Node Package Manager (验证 node -v  npm -v) npm:node packge manager

2、打开控制台（cmd），执行npm install -g less (验证 lessc -v) node packet manager

3、命令行编译 lessc path/xxx.less path/xxx.css

#### 编译

浏览器只能识别CSS，LESS只是用来提升CSS可维护性的一个工具，所最终需要将LESS编译成CSS，然而通过命令行编译效率比较低下，一般都会借助于编辑器来完成编译，以sublime_text为例，sublime_text默认并不支持LESS的编译操作，需要安装插件实现。

1、执行npm install -g less-plugin-clean-css（使用sublime_text才用）

2、ctrl+shit+p打开命令面板

3、输入install package然后回车

4、安装 LESS、lessc、Less2Css三个插件

5、alt+s快捷键即可实现编译

### less语法

``` css
//语法修改
//变量定义 @变量名:值;
@baseColor:#e92322;
div {
    color:@baseColor;
}
//混入：可以将一个定义好的样式引入另一个样式中 类似函数的调用

.addRadius(@r:10px){
    border-radius: @r;
    -webkit-border-radius: @r;
    -moz-border-radius: @r;
}
div{
    width: 200px;
    height: 200px;
    //引入已经写好的圆角样式
    .addRadius();
}
//嵌套:实现选择器的继承，减少代码量，同时使代码结构更加清晰
.jd_header{
    width: 200px;
    height: 200px;
    .addRadius();
    > div{
        &::before{
            content: "";
        }
        width: 100%;
        > h3{
            height: 20px;
            &:hover{
                height: 50px;
            }
        }
    }
}
```



### 垂直水平居中

1.水平居中

脱离文档流

- margin：o auto；
- 负margin法：先left：50%，然后在给一个负margin-left居中元素宽度的一半
- transform： translateX：-50%
- 给父容器设置text-align :center, 然后给子容器加上display：inline-block;

2.垂直居中

脱离文档流

- margin： auto 0；
- 负margin法：先top：50%，然后在给一个负margin-top居中元素宽度的一半
- transform： translateY：-50%

3.table-cell法 和flex弹性盒子法

table-cell法（对低版本IE兼容比较良好）

```css
div {
    display: table-cell;
    width: 200px;
    height: 200px;
    text-align: center;
    vertical-align: middle;
}
```

flex法：

``` css
.container{
width: 300px;
height: 200px;
display: -webkit-flex;        //兼容weikit
display: flex;
-webkit-align-items: center;  //兼容weikit
align-items: center;
-webkit-justify-content: center;   //兼容weikit
justify-content: center;
}
```

### 三角形画法

从底向上

``` css
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom：100px solid red;
}
```

transparent属性相当于rgba（0,0,0,0,）全透明的颜色

### 清除浮动的方法

- BFC消除浮动法：给父盒子加上overflow：hidden；

 	优点：  代码简洁

​	缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。

- 额外标签法：在浮动元素末尾添加一个空的标签例如 <div style="clear:both"></div>，或则其他标签br等亦可。

​    优点： 通俗易懂，书写方便

​    缺点： 添加许多无意义的标签，结构化较差。

- 使用after伪元素清除浮动（推荐）

- ```css 
   .clearfix:after {  content: "."; display: block; height: 0; clear: both; visibility: hidden;  }   
    
   .clearfix {*zoom: 1;}   /* IE6、7 专有 */
  ```

  

- 优点： 符合闭合浮动思想  **结构语义化正确**

  缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。

### background属性详解

- background-color  背景颜色

- **background-position 背景图片位置（精灵图常用）**

- background-size  ：规定背景图像的尺寸

- **background-repeat：属性设置是否及如何重复背景图像。（精灵图常用）**

- background-origin：相对于内容框来定位背景图像（目前不常用）![background-origin](C:\Users\92530\Desktop\面试复习\images\background-origin.png)

- background-clip：规定背景的绘制区域（目前我不常用）

  ```
  background-clip: border-box|padding-box|content-box;
  ```

- **background-attachment：规定背景图像是否固定或者随着页面的其余部分滚动（可以用来视差滚动的效果）**

- **background-image：设置背景图片（精灵图常用）**

- 缩写方式（更简洁明了，且对低版本的兼容性更高）

``` css
div {
    //   缩写必须按顺序来
    //（<颜色> <background-image背景图片> <background-repeat重复背景图片> 
              <background-attachment 背景固定方式>  <背景图片位置>）
	background: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center;    
}

```

### 兼容性问题

​	靠积累了这个，常见的要知道，比如CSS3新添加的动画和transition，IE6.7.8都不支持，以及一些H5标签的兼容性问题，JS的原生方法如getElementByClassName，IE低版本不支持，可以采用兼容性写法等等，这个要靠平时多积累

```javascript
//1 getElementsByClassName方法在IE8以下版本不支持，因此采用这种写法
/////////////////////////////////////////////////////////////////////
eg.getElementsByClassName = function (className, element) {
    //如果支持则直接返回该方法
    if (document.getElementsByClassName) {
        return (element || document).getElementsByClassName(className);
    }
    //如果不支持则采用兼容性写法
    var children = (element || document).getElementByTagName("*");
    var elements = new Array();

    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        var classNames = child.className.split(' ');
        //将class样式分割
        for (var j = 0; j < classNames.length; ++j) {
            if (classNames[j] == className) {
                elements.push(child);
                break;
            }
        }
    }
    return elements;
}
///////////////////////////////////////////////////////////////////
```

## 浏览器前缀

| 浏览器前缀 | 浏览器                                 |
| ---------- | -------------------------------------- |
| -webkit-   | Google Chrome, Safari, Android Browser |
| -moz-      | Firefox                                |
| -o-        | Opera                                  |
| -ms-       | Internet Explorer, Edge                |
| -khtml-    | Konqueror                              |

### H5相关

##### **AJAX**

​	最重要的就是AJAX以及跨域相关知识，掌握不了就是切图仔无疑（目前笔者就是切图仔T.T），别去面试了，因为这是工作中最常用的

###### 标签语义化

###### H5新加入的API

###### localStorage、sessionStorage、Cookie

- localStorage - 没有时间限制的数据存储
- sessionStorage - 针对一个 session 的数据存储

###### canvas

###### SVG

**web worker 是运行在后台的 JavaScript，不会影响页面的性能。**（了解）

<参考：http://www.w3school.com.cn/html5/html_5_webworkers.asp>

地理定位（好像国内不常用？一般用百度的，不清楚，我的见识浅显，希望读者可以给我指出错误）

### 常用布局

#### 圣杯布局

优先渲染中间栏适应

两边侧边栏固定，中间自适应

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>圣杯布局</title>
    <style>
        div{
            padding: 0;
            margin: 0;
        }
        .container{
            padding: 0 200px;
            background-color: #eee;
            height: 200px;
            /* min-width: 400px; */
            /* 加上一个最小像素可以让布局不乱 */
        }
        .left,
        .right{
            width: 200px;
            height: 200px;
            background-color: red;
            float: left;
        }
        .main{
            width: 100%;
            height: 200px;
            background-color: blue;
            float: left;
        }
        .left{
            margin-left: -100%;
            position: relative;
            left: -200px;
        }
        .right{
            margin-left: -200px;
            position: relative;
            right: -200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 先加载中间再加载两边 -->
        <div class="main">中间中间间中间中间中间中间</div>
        <div class="left">左边</div>
        <div class="right">右边</div>
    </div>
</body>
</html>
```



#### 双飞翼布局

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>双飞翼布局</title>
    <style>
        div{
            padding: 0;
            margin: 0;
        }
        .container{
            background-color: #eee;
            min-width: 400px;
            /* 加上一个最小像素可以让布局不乱 */
        }
        .left,
        .right{
            width: 200px;
            height: 200px;
            background-color: red;
            float: left;
        }
        .main{
            width: 100%;
            height: 200px;
            background-color: blue;
            float: left;
        }
        .left{
            margin-left: -100%;
        }
        .right{
            margin-left: -200px;
        }
        .main_w{
            margin: 0 200px;
         }
    </style>
</head>
<body>
    <div class="container">
        <!-- 先加载中间再加载两边 -->
        <div class="main">
            <div class="main_w">
                    中间栏
            </div>
        </div>
        <div class="left">左边栏</div>
        <div class="right">右边栏</div>
    </div>
</body>
</html>
```



### BFC

BFC(Block formatting context)块级格式化上下文

display 属性为 block, list-item, table 的元素，能产生BFC.

**同样，要给这些元素添加如下属性就可以触发BFC。**

-float属性不为none

-position为absolute或fixed

-display为inline-block, table-cell, table-caption, flex, inline-flex

-overflow不为visible。

#### BFC元素所具有的特性

BFC布局规则特性：

1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.

2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠

3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。

1. BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。
2. 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。

它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。

#### BFC的主要用途

(1) 清除元素内部浮动

只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。

主要用到 

```
计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。
```

<img src="C:/Users/92530/Desktop/%E7%AC%94%E8%AE%B0%E7%9F%A5%E8%AF%86%E7%82%B9/media/fu.jpg" />
(2) 解决外边距合并问题

外边距合并的问题。

主要用到 

```
盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠
```

属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。

<img src="C:/Users/92530/Desktop/%E7%AC%94%E8%AE%B0%E7%9F%A5%E8%AF%86%E7%82%B9/media/ma.png" />

(3) 制作右侧自适应的盒子问题

主要用到 

```
普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文
```

<img src="C:/Users/92530/Desktop/%E7%AC%94%E8%AE%B0%E7%9F%A5%E8%AF%86%E7%82%B9/media/you.png" />

#### BFC 总结

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。

### 渐进增强和优雅降级

#### 渐进增强 

progressive enhancement：

针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

#### 优雅降级 

graceful degradation：

一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

### 背景渐变

​	在线性渐变过程中，颜色沿着一条直线过渡：从左侧到右侧、从右侧到左侧、从顶部到底部、从底部到顶部或着沿任何任意轴。

兼容性问题很严重，必须加上浏览器前缀。

线性渐变语法格式： 

```css
background:-webkit-linear-gradient(渐变的起始位置， 起始颜色， 结束颜色)；
```

```css
background:-webkit-linear-gradient(渐变的起始位置， 颜色 位置， 颜色位置....)；
```



### echarts图表

### layer ui框架

## JS

## 原生JS

**1.最基本的：隐式转换、数组、字符串、正则 、Date相关方法及DOM操作**

- ​	dom操作：增删改查，操作节点
- ​    bom：bom对象，事件，表单
- ​    错误处理

2.函数：作用域、**闭包**、垃圾回收 

- this相关：**this指向问题**
- 手写bind()、call()、apply()

3.对象 ：**原型**、原型链、构造函数、创建对象的模式、继承、包装对象、深拷贝、浅拷贝、深复制、浅复制

4.同步异步：async与await、定时器、微任务，宏任务

4.ES6相关：let和const、模板字符串、**promise**、类、super、static以及

5.ES6新加方法：**Object.assign()**

6.额外技能：github issue 、资料查阅工具等等

7.工作常用： 数组列表 分页 

#### 深拷贝

这个文章写得非常好<https://www.jianshu.com/p/b08bc61714c7>

### 日常开发常用深拷贝，序列化反序列化法

**唯一局限性：只能深拷贝对象和数组，对于其他种类的对象，会失真。**

```javascript
function deepClone(obj){
    return JSON.parse(JSON.stringify(obj));
}
```

**搞事情深拷贝:能拷贝自身可枚举、自身不可枚举、自身 Symbol 类型键、原型上可枚举、原型上不可枚举、原型上的 Symol 类型键，循环引用也可以拷的深拷贝函数：**2333.

```JavaScript
// 将之前写的 deepClone 函数封装一下
function cloneDeep(obj) {
    let family = {}
    let parent = Object.getPrototypeOf(obj)

    while (parent != null) {
        family = completeAssign(deepClone(family), parent)
        parent = Object.getPrototypeOf(parent)
    }

    // 下面这个函数会拷贝所有自有属性的属性描述符,来自于 MDN
    // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    function completeAssign(target, ...sources) {
        sources.forEach(source => {
            let descriptors = Object.keys(source).reduce((descriptors, key) => {
                descriptors[key] = Object.getOwnPropertyDescriptor(source, key)
                return descriptors
            }, {})

            // Object.assign 默认也会拷贝可枚举的Symbols
            Object.getOwnPropertySymbols(source).forEach(sym => {
                let descriptor = Object.getOwnPropertyDescriptor(source, sym)
                if (descriptor.enumerable) {
                    descriptors[sym] = descriptor
                }
            })
            Object.defineProperties(target, descriptors)
        })
        return target
    }

    return completeAssign(deepClone(obj), family)
}

```



#### 闭包

能够访问其他函数内部局部变量的函数

能将局部变量的值保存在内存中

在数组中保存函数

一个函数引用外部局部变量也是闭包

可以做一个预编译的函数

#### 数组去重

第一种方法：indexOf()：查找当前查询值在当前数组的索引，如果不存在则返回-1

建立新数组，拿到旧数组的每一位，如果新数组不存在，那么就push 进去

```javascript
function unique1(arr){
    var newArr = [];
    var len =arr.length;
    for(var i =0; i<len ;i++){
        if(newArr.indexOf(arr[i]) == -1){
            newArr.push(arr[i]);
        }
    }
    return newArr;
}
```

第二种方法:

将数组的元素值作为对象的属性名，借助对象 obj{}:同个对象中不能有同样的属性名

```javascript
function unique2(arr){
    var newArr = [];
    var obj = {};
    var len = arr.length;
    for(var i = 0;i<len ;++i){
        if(!obj[arr[i]]){
        newArr.push(arr[i]);
        obj[arr[i]] = 1; //只要赋值为一个bool为true的值
        }
    }
    return newArr;
}
```

第三种方法：ES6的symbol

```javascript
new Set(arr);
//Set里的值都是独一无二的
```



### DOM

##### 原生JS添加类名 删除类名

```JavaScript
为 <div> 元素添加 class:

document.getElementById("myDIV").classList.add("mystyle");

为 <div> 元素添加多个类:

document.getElementById("myDIV").classList.add("mystyle", "anotherClass", "thirdClass");

为 <div> 元素移除一个类:

document.getElementById("myDIV").classList.remove("mystyle");

为 <div> 元素移除多个类:

document.getElementById("myDIV").classList.remove("mystyle", "anotherClass", "thirdClass");

检查是否含有某个CSS类

myDiv.classList.contains('myCssClass'); //return true or false
```



## 代码优化

避免双重解释：js代码想解析js代码出现双重解释，非常浪费性能，会创建一个新的js解释器来解释内部的js代码

当使用eval（）函数或是Function构造函数以及setTimeout（）传一个字符串时都会发生这种情况。如下

```javascript
//eval//
eval(alert("hello world!"));//避免
alert("hello world!");//修改
//Function//
var sayHi = new Function(alert("hello"));//避免
var sayHi = function(){  //修改
    alert("hello");
}
//setTimeout//
setTimeout('alert("hello");',500)//避免
setTimeout(function(){//修改
    alert("hello");
},500)
```



## AJAX

##### 同源策略

同源是指，域名，协议，端口相同。

浏览器这个策略的本质是一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。**但浏览器并不阻止你向另一个域名发送请求，只是在接收加载资源之前对其来源进行了检查，然后限制加载**。即**拦截的是服务器响应回来的数据**。

##### cors跨域

<http://www.cnblogs.com/moretry/p/4154479.html>

​      在我们日常的项目开发时使用AJAX，传统的Ajax请求只能获取在同一个域名下面的资源，但是HTML5打破了这个限制，允许Ajax发起跨域的请求。浏览器是可以发起跨域请求的，比如你可以外链一个外域的图片或者脚本。但是Javascript脚本是不能获取这些资源的内容的，它只能被浏览器执行或渲染。主要原因还是出于安全考虑，浏览器会限制脚本中发起的跨站请求。([同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)， 即JavaScript或Cookie只能访问同域下的内容)。跨域的解决方案有多重JSONP、Flash、Iframe等，当然还有[CORS（跨域资源共享，Cross-Origin Resource Sharing）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)今天就来了解下CORS的原理，以及如何使用。

**一、CORS概述**

跨源资源共享标准通过新增一系列 HTTP 头，让服务器能声明那些来源可以通过浏览器访问该服务器上的各类资源（包括CSS、图片、JavaScript 脚本以及其它类资源）。另外，**对那些会对服务器数据造成破坏性影响的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些MIME类型的POST请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。**服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）。

**二、CORS原理**

例如：域名A(http://a.example)的某 Web 应用程序中通过<img>标签引入了域名B(http://b.foo)站点的某图片资源(http://b.foo/image.jpg)。这就是一个跨域请求，请求http报头包含Origin: http://a.example，如果返回的http报头包含响应头 Access-Control-Allow-Origin: http://a.example （或者Access-Control-Allow-Origin: http://a.example），表示域名B接受域名B下的请求，那么这个图片就运行被加载。否则表示拒绝接受请求。

**三、CORS跨域请求控制方法**

1.http请求头

Origin: 普通的HTTP请求也会带有，在CORS中专门作为Origin信息供后端比对,表明来源域。

Access-Control-Request-Method: 接下来请求的方法，例如PUT, DELETE等等

Access-Control-Request-Headers: 自定义的头部，所有用setRequestHeader方法设置的头部都将会以逗号隔开的形式包含在这个头中

2.http响应头

然后浏览器再根据服务器的返回值判断是否发送非简单请求。简单请求前面讲过是直接发送，只是多加一个origin字段表明跨域请求的来源。然后服务器处理完请求之后，会再返回结果中加上如下控制字段

Access-Control-Allow-Origin: 允许跨域访问的域，可以是一个域的列表，也可以是通配符"*"。这里要注意Origin规则只对域名有效，并不会对子目录有效。即http://foo.example/subdir/ 是无效的。但是不同子域名需要分开设置，这里的规则可以参照同源策略

Access-Control-Allow-Credentials: 是否允许请求带有验证信息，XMLHttpRequest请求的withCredentials标志设置为true时，认证通过，浏览器才将数据给脚本程序。

Access-Control-Expose-Headers: 允许脚本访问的返回头，请求成功后，脚本可以在XMLHttpRequest中访问这些头的信息

Access-Control-Max-Age: 缓存此次请求的秒数。在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据，非常有用，大幅优化请求次数

Access-Control-Allow-Methods: 允许使用的请求方法，以逗号隔开

Access-Control-Allow-Headers: 允许自定义的头部，以逗号隔开，大小写不敏感

**四、浏览器支持情况**

在大部分现代浏览器中有所支持，支持(部分支持)CORS协议的浏览器有IE8+, Firefox5+, Chrome12+, Safari4+，移动端几乎全支持。

![img](https://images0.cnblogs.com/blog/533389/201412/092245026509954.png)

注：Internet Explorer 8 、9使用 XDomainRequest 对象实现CORS。

**五、CORS使用案例**

案例环境：客户端使用jQuery，服务端WebApi（2.2）。因本人使用.net语言，所以服务端就使用webApi来演示了。 

首先新建一个webApi项目，这里就不截图一步步介绍了，然后使用Nuget安装支持cors的扩展组件，

Install-Package Microsoft.AspNet.WebApi.Cors

然后打开App_Start问价夹下的WebConfig.cs配置文件类，在Register方法中配置一个全局的cors，为了方便我将一些参数配置到web.config配置文件中

![img](https://images0.cnblogs.com/blog/533389/201412/092304104937815.gif)



```
    <add key="cors_allowOrigins" value="*"/>
    <add key="cors_allowHeaders" value="*"/>
    <add key="cors_allowMethods" value="*"/>
```

 ![img](https://images0.cnblogs.com/blog/533389/201412/092305529789938.gif)



```
            var allowOrigins = ConfigurationManager.AppSettings["cors_allowOrigins"];
            var allowHeaders = ConfigurationManager.AppSettings["cors_allowHeaders"];
            var allowMethods = ConfigurationManager.AppSettings["cors_allowMethods"];
            var globalCors = new EnableCorsAttribute(allowOrigins, allowHeaders, allowMethods);
            config.EnableCors(globalCors);
```

 

如果不想使用全局的CORS，可以在某个方法或者ApiController上这样配置：[EnableCors(origins: "*", headers: "*", methods: "*")]，可以使用具体的参数，多个参数以逗号分隔，不用说，肯定英文逗号。origins 域名要带上http的顶级域名。需要添加 using System.Web.Http.Cors;

 

一般请求来说，客户端的AJAX请求不需要做任何改变，只需要服务端稍作改变即可。

客户端js代码：     apiRootPath是我预先设置的api的顶级域名。

```
$.ajax({
    url: apiRootPath + "api/Account/Register",
    type: "post",
    data: {
        "UserName": mobile,
        "Password": pwd
    },
    dataType: "json",
    success: function (data) {
        if (data.State == true) {
            RegSuccess(mobile, pwd);
        } else {
            $("#errorText").html(data.Message);
            $("#registerBtn").text("注册");
        }
    }
});
```

因为我配置了全局的CORS方法，而且服务端没有特别之处了，和普通的网站（不跨越）写法一致，这里就不予贴出了。

如果需要对请求进行身份验证，怎么办？我们一cookies实现这个验证。

```
$.ajax({
    url: apiRootPath + "api/Account/Login",
    type: "post",
    data: {
        "UserName": userName,
        "Password": password
    },
    crossDomain: true,
    xhrFields: {
        withCredentials: true
    },
    dataType: "json",
    success: function (data) {
        if (data.State == true) {
            MLogin(userName, password);
        } else {
            $("#loginBtn").text("登录");
            $("#errorText").html(data.Message);
        }
    }
});
```

注意这个两句话：crossDomain: true,xhrFields: {withCredentials: true}

**六：安全隐患**

 如果程序猿偷懒将Access-Control-Allow-Origin设置为：Access-Control-Allow-Origin: * 允许任何来自任意域的跨域请求，那么久存在被 DDoS攻击的可能。



### 原型和构造函数

- 原型是function对象的一个属性，该属性是一个对象

- 原型是本身就存在的

  - 原型对象中有默认有两个属性，一个是constructor，该属性指向基于该原型的实例的构造函数，
  - 另一个属性是隐式属性  `__proto`__

- **绝大多数对象**的原型最终都指向Object，除了特殊创建的无原型对象，如下

- ```javascript
  var obj = Object.create(null);
  ```

  **该方法创建出来的对象无原型，并且如果后期为其指定 `__proto`__属性,不会拥有继承特性！！**

  null 和undefined是没有原型的

  tip：null为空对象指针，真正的空对象，{ }也是空的对象，但是还有原型属性


#### prototype的应用：

1.用于提取共有属性

当我们使用构造函数创建属性时，如果出现重复的属性应该用原型来创建，可以减少代码量和冗余，即重复多次使用的属性应该用原型指配，构造函数用来指配特定的对象

#### 原型的增删改查

只能直接对原型进行操作才能成功，否则相当于直接对实例进行添加或修改

**特殊情况：引用值属性**

对于存在于父链上的引用值，如果进行增加可以使父链上的引用值本身发生变化，因为从子链上进行引用值取用，相当于直接对引用值本身进行操作



# 网络基础

#### 关于TCP的三次握手四次挥手

拓展资料：<https://juejin.im/post/5ccd0dfc6fb9a0324a08bb73>

SYN：握手建立信号

ACK：应答同意信号

FIN：挥手信号（断开连接信号)

seq：包的序列号用于分割发送时判断怎么合并

ack：确认号，发送包的序列号

###### tip:SYN攻击

SYN攻击就是在客户端发送SYN信号给服务器端建立连接，但是还未收到服务器端的答复时，被黑客伪造请求发送**随机IP**的SYN请求给服务器，造成服务器的请求队列爆满，使正常的SYN信号无法送达，从而使服务器崩溃瘫痪的攻击。

当出现大量的半连接状态时，且源IP地址是随机的，基本可以判断收到了SYN攻击

解决办法：一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固TCP/IP协议栈防范.但必须清楚的是，SYN攻击不能完全被阻止，我们所做的是尽可能的减轻SYN攻击的危害，除非将TCP协议重新设计。

#### 常见http请求头



# 计算机基础

## 缓存相关（非常重要）



#### cache替换策略

FIFO算法 ：先进先出算法

（好！）LRU算法 :最近最久未使用算法