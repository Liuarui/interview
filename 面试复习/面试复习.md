# CSS3+H5

 [CSS3.0 帮助文档.chm](CSS3.0 帮助文档.chm) 

注意：CSS3不支持IE6，7，8。兼容性

### 一、flex弹性布局：

<参考资料：http://www.runoob.com/w3cnote/flex-grammar.html>

**兼容性问题:**Webkit内核的浏览器，必须加上-webkit前缀。

```css
.box{
  display: -webkit-flex; /* Safari */
  display: flex;
}
```

**注意**：设为Flex布局以后，**子元素**的float、clear和vertical-align属性将失效。

##### 1.基本概念

采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。

主轴：橫                  交叉轴：竖

##### **2.容器具有的属性**

###### **flex-direction**

**决定主轴的方向（项目的排列方向）**

- row（默认值）：主轴为水平方向，起点在左端。
- row-reverse：主轴为水平方向，起点在右端。
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿。

###### **flex-wrap**

**定义如果一条轴线排不下，如何换行。**

- nowrap（默认值） ：不换行（**会把项目压缩**）
-  wrap  ：换行
- wrap-reverse： 换行，第一行在下面

###### **flex-flow**

**属性和flex-wrap属性的简写形式**

```css
.box {
  flex-flow: flex-direction flex-wrap;
}
```

###### **justify-content**

**项目在主轴上的对齐方式。**

- flex-start（默认值）：左对齐
- flex-end：右对齐
- center： 居中
- space-between：两端对齐，项目之间的间隔都相等。
- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

###### **align-items**

**定义项目在交叉轴上如何对齐**

- flex-start：交叉轴的起点对齐。
- flex-end：交叉轴的终点对齐。
- center：交叉轴的中点对齐。
- baseline: 项目的第一行文字的基线对齐。
- stretch（**默认值**）：如果项目未设置高度或设为auto，将占满整个容器的高度。

###### **align-conten**

定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

##### 3.项目具有的属性****

1. order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。

2. flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

3. flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

4. flex-basis：

   定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。

   设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

5. **flex：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。**

6. align-self：允许单个项目有与其他项目不一样的对齐方式，**可覆盖align-items属性**。默认值为**auto**，**表示继承父元素的align-items属性**，如果没有父元素，则等同于stretc

   该属性可取6个值，除了auto，其他都与align-items属性完全一致。

   ``` css
   .item {
     align-self: auto | flex-start | flex-end | center | baseline | stretch;
   }
   ```

### 二、transtion：过渡

语法格式:

```
transition: 要过渡的属性  花费时间  运动曲线  何时开始;
```

| 属性                       | 描述                                         | CSS  |
| :------------------------- | -------------------------------------------- | ---- |
| transition                 | 简写属性，用于在一个属性中设置四个过渡属性。 | 3    |
| transition-property        | 规定应用过渡的 CSS 属性的名称。              | 3    |
| transition-duration        | 定义过渡效果花费的时间。默认是 0。           | 3    |
| transition-timing-function | 规定过渡效果的时间曲线。默认是 "ease"。      | 3    |
| transition-delay           | 规定过渡效果何时开始。默认是 0。             | 3    |

运动曲线示意图：

![transition](C:\Users\92530\Desktop\面试复习\images\transition.png)

```css
img {
  width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%;
  transition:transform 0.5s ease-in 0s;
}
img:hover {
  transform:rotate(180deg);
}
```

### 三、@media

针对不同媒体类型（或者说屏幕宽度）自适应采用不同的样式规则。当你重置浏览器大小的过程中，页面会根据浏览器的宽度和高度重新渲染页面。

用于响应式布局，根据设备屏幕不同

使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。

@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。

当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面

### 四、栅格原理（col-xs-12）：

响应式开发



![col-xs-12](C:\Users\92530\Desktop\面试复习\images\col-xs-12.png)

### 五、垂直水平居中

1.水平居中

脱离文档流

- margin：o auto；
- 负margin法：先left：50%，然后在给一个负margin-left居中元素宽度的一半
- transform： translateX：-50%
- 给父容器设置text-align :center, 然后给子容器加上display：inline-block;

2.垂直居中

脱离文档流

- margin： auto 0；
- 负margin法：先top：50%，然后在给一个负margin-top居中元素宽度的一半
- transform： translateY：-50%

3.table-cell法 和flex弹性盒子法

table-cell法（对低版本IE兼容比较良好）

```css
div {
    display: table-cell;
    width: 200px;
    height: 200px;
    text-align: center;
    vertical-align: middle;
}
```

flex法：

``` css
.container{
width: 300px;
height: 200px;
display: -webkit-flex;        //兼容weikit
display: flex;
-webkit-align-items: center;  //兼容weikit
align-items: center;
-webkit-justify-content: center;   //兼容weikit
justify-content: center;
}
```

### 六、三角形画法

从底向上

``` css
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom：100px solid red;
}
```

transparent属性相当于rgba（0,0,0,0,）全透明的颜色

### 七、清除浮动的方法

- BFC消除浮动法：给父盒子加上overflow：hidden；

 	优点：  代码简洁

​	缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。

- 额外标签法：在浮动元素末尾添加一个空的标签例如 <div style="clear:both"></div>，或则其他标签br等亦可。

​    优点： 通俗易懂，书写方便

​    缺点： 添加许多无意义的标签，结构化较差。

- 使用after伪元素清除浮动（推荐）

- ```css 
   .clearfix:after {  content: "."; display: block; height: 0; clear: both; visibility: hidden;  }   
    
   .clearfix {*zoom: 1;}   /* IE6、7 专有 */
  ```

  

- 优点： 符合闭合浮动思想  **结构语义化正确**

  缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。

### 八、background属性详解

- background-color  背景颜色

- **background-position 背景图片位置（精灵图常用）**

- background-size  ：规定背景图像的尺寸

- **background-repeat：属性设置是否及如何重复背景图像。（精灵图常用）**

- background-origin：相对于内容框来定位背景图像（目前不常用）![background-origin](C:\Users\92530\Desktop\面试复习\images\background-origin.png)

- background-clip：规定背景的绘制区域（目前我不常用）

  ```
  background-clip: border-box|padding-box|content-box;
  ```

- **background-attachment：规定背景图像是否固定或者随着页面的其余部分滚动（可以用来视差滚动的效果）**

- **background-image：设置背景图片（精灵图常用）**

- 缩写方式（更简洁明了，且对低版本的兼容性更高）

``` css
div {
    //   缩写必须按顺序来
    //（<颜色> <background-image背景图片> <background-repeat重复背景图片> 
              <background-attachment 背景固定方式>  <背景图片位置>）
	background: #ff0000 url(/i/eg_bg_03.gif) no-repeat fixed center;    
}

```

### 九、兼容性问题

​	靠积累了这个，常见的要知道，比如CSS3新添加的动画和transition，IE6.7.8都不支持，以及一些H5标签的兼容性问题，JS的原生方法如getElementByClassName，IE低版本不支持，可以采用兼容性写法等等，这个要靠平时多积累

```javascript
//1 getElementsByClassName方法在IE8以下版本不支持，因此采用这种写法
/////////////////////////////////////////////////////////////////////
eg.getElementsByClassName = function (className, element) {
    //如果支持则直接返回该方法
    if (document.getElementsByClassName) {
        return (element || document).getElementsByClassName(className);
    }
    //如果不支持则采用兼容性写法
    var children = (element || document).getElementByTagName("*");
    var elements = new Array();

    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        var classNames = child.className.split(' ');
        //将class样式分割
        for (var j = 0; j < classNames.length; ++j) {
            if (classNames[j] == className) {
                elements.push(child);
                break;
            }
        }
    }
    return elements;
}
///////////////////////////////////////////////////////////////////
```

### 十、H5相关

##### **AJAX**

​	最重要的就是AJAX以及跨域相关知识，掌握不了就是切图仔无疑（目前笔者就是切图仔T.T），别去面试了，因为这是工作中最常用的

###### 标签语义化

###### H5新加入的API

###### localStorage、sessionStorage、Cookie

- localStorage - 没有时间限制的数据存储
- sessionStorage - 针对一个 session 的数据存储

###### canvas

###### SVG

**web worker 是运行在后台的 JavaScript，不会影响页面的性能。**（了解）

<参考：http://www.w3school.com.cn/html5/html_5_webworkers.asp>

地理定位（好像国内不常用？一般用百度的，不清楚，我的见识浅显，希望读者可以给我指出错误）

## JS

## 原生JS

**1.最基本的：隐式转换、数组、字符串、正则 、Date相关方法及DOM操作**

- ​	dom操作：增删改查，操作节点
- ​    bom：bom对象，事件，表单
- ​    错误处理

2.函数：作用域、**闭包**、垃圾回收 

- this相关：**this指向问题**
- 手写bind()、call()、apply()

3.对象 ：**原型**、原型链、构造函数、创建对象的模式、继承、包装对象、深拷贝、浅拷贝、深复制、浅复制

4.同步异步：async与await、定时器、微任务，宏任务

4.ES6相关：let和const、模板字符串、**promise**、类、super、static以及

5.ES6新加方法：**Object.assign()**

6.额外技能：github issue 、资料查阅工具等等

7.工作常用： 数组列表 分页 

## AJAX

##### 同源策略

同源是指，域名，协议，端口相同。

浏览器这个策略的本质是一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。**但浏览器并不阻止你向另一个域名发送请求，只是在接收加载资源之前对其来源进行了检查，然后限制加载**。即**拦截的是服务器响应回来的数据**。

##### cors跨域

<http://www.cnblogs.com/moretry/p/4154479.html>

​      在我们日常的项目开发时使用AJAX，传统的Ajax请求只能获取在同一个域名下面的资源，但是HTML5打破了这个限制，允许Ajax发起跨域的请求。浏览器是可以发起跨域请求的，比如你可以外链一个外域的图片或者脚本。但是Javascript脚本是不能获取这些资源的内容的，它只能被浏览器执行或渲染。主要原因还是出于安全考虑，浏览器会限制脚本中发起的跨站请求。([同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)， 即JavaScript或Cookie只能访问同域下的内容)。跨域的解决方案有多重JSONP、Flash、Iframe等，当然还有[CORS（跨域资源共享，Cross-Origin Resource Sharing）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)今天就来了解下CORS的原理，以及如何使用。

**一、CORS概述**

跨源资源共享标准通过新增一系列 HTTP 头，让服务器能声明那些来源可以通过浏览器访问该服务器上的各类资源（包括CSS、图片、JavaScript 脚本以及其它类资源）。另外，**对那些会对服务器数据造成破坏性影响的 HTTP 请求方法（特别是 GET 以外的 HTTP 方法，或者搭配某些MIME类型的POST请求），标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。**服务器端也可以通知客户端，是不是需要随同请求一起发送信用信息（包括 Cookies 和 HTTP 认证相关数据）。

**二、CORS原理**

例如：域名A(http://a.example)的某 Web 应用程序中通过<img>标签引入了域名B(http://b.foo)站点的某图片资源(http://b.foo/image.jpg)。这就是一个跨域请求，请求http报头包含Origin: http://a.example，如果返回的http报头包含响应头 Access-Control-Allow-Origin: http://a.example （或者Access-Control-Allow-Origin: http://a.example），表示域名B接受域名B下的请求，那么这个图片就运行被加载。否则表示拒绝接受请求。

**三、CORS跨域请求控制方法**

1.http请求头

Origin: 普通的HTTP请求也会带有，在CORS中专门作为Origin信息供后端比对,表明来源域。

Access-Control-Request-Method: 接下来请求的方法，例如PUT, DELETE等等

Access-Control-Request-Headers: 自定义的头部，所有用setRequestHeader方法设置的头部都将会以逗号隔开的形式包含在这个头中

2.http响应头

然后浏览器再根据服务器的返回值判断是否发送非简单请求。简单请求前面讲过是直接发送，只是多加一个origin字段表明跨域请求的来源。然后服务器处理完请求之后，会再返回结果中加上如下控制字段

Access-Control-Allow-Origin: 允许跨域访问的域，可以是一个域的列表，也可以是通配符"*"。这里要注意Origin规则只对域名有效，并不会对子目录有效。即http://foo.example/subdir/ 是无效的。但是不同子域名需要分开设置，这里的规则可以参照同源策略

Access-Control-Allow-Credentials: 是否允许请求带有验证信息，XMLHttpRequest请求的withCredentials标志设置为true时，认证通过，浏览器才将数据给脚本程序。

Access-Control-Expose-Headers: 允许脚本访问的返回头，请求成功后，脚本可以在XMLHttpRequest中访问这些头的信息

Access-Control-Max-Age: 缓存此次请求的秒数。在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据，非常有用，大幅优化请求次数

Access-Control-Allow-Methods: 允许使用的请求方法，以逗号隔开

Access-Control-Allow-Headers: 允许自定义的头部，以逗号隔开，大小写不敏感

**四、浏览器支持情况**

在大部分现代浏览器中有所支持，支持(部分支持)CORS协议的浏览器有IE8+, Firefox5+, Chrome12+, Safari4+，移动端几乎全支持。

![img](https://images0.cnblogs.com/blog/533389/201412/092245026509954.png)

注：Internet Explorer 8 、9使用 XDomainRequest 对象实现CORS。

**五、CORS使用案例**

案例环境：客户端使用jQuery，服务端WebApi（2.2）。因本人使用.net语言，所以服务端就使用webApi来演示了。 

首先新建一个webApi项目，这里就不截图一步步介绍了，然后使用Nuget安装支持cors的扩展组件，

Install-Package Microsoft.AspNet.WebApi.Cors

然后打开App_Start问价夹下的WebConfig.cs配置文件类，在Register方法中配置一个全局的cors，为了方便我将一些参数配置到web.config配置文件中

![img](https://images0.cnblogs.com/blog/533389/201412/092304104937815.gif)



```
    <add key="cors_allowOrigins" value="*"/>
    <add key="cors_allowHeaders" value="*"/>
    <add key="cors_allowMethods" value="*"/>
```

 ![img](https://images0.cnblogs.com/blog/533389/201412/092305529789938.gif)



```
            var allowOrigins = ConfigurationManager.AppSettings["cors_allowOrigins"];
            var allowHeaders = ConfigurationManager.AppSettings["cors_allowHeaders"];
            var allowMethods = ConfigurationManager.AppSettings["cors_allowMethods"];
            var globalCors = new EnableCorsAttribute(allowOrigins, allowHeaders, allowMethods);
            config.EnableCors(globalCors);
```

 

如果不想使用全局的CORS，可以在某个方法或者ApiController上这样配置：[EnableCors(origins: "*", headers: "*", methods: "*")]，可以使用具体的参数，多个参数以逗号分隔，不用说，肯定英文逗号。origins 域名要带上http的顶级域名。需要添加 using System.Web.Http.Cors;

 

一般请求来说，客户端的AJAX请求不需要做任何改变，只需要服务端稍作改变即可。

客户端js代码：     apiRootPath是我预先设置的api的顶级域名。

```
$.ajax({
    url: apiRootPath + "api/Account/Register",
    type: "post",
    data: {
        "UserName": mobile,
        "Password": pwd
    },
    dataType: "json",
    success: function (data) {
        if (data.State == true) {
            RegSuccess(mobile, pwd);
        } else {
            $("#errorText").html(data.Message);
            $("#registerBtn").text("注册");
        }
    }
});
```

因为我配置了全局的CORS方法，而且服务端没有特别之处了，和普通的网站（不跨越）写法一致，这里就不予贴出了。

如果需要对请求进行身份验证，怎么办？我们一cookies实现这个验证。

```
$.ajax({
    url: apiRootPath + "api/Account/Login",
    type: "post",
    data: {
        "UserName": userName,
        "Password": password
    },
    crossDomain: true,
    xhrFields: {
        withCredentials: true
    },
    dataType: "json",
    success: function (data) {
        if (data.State == true) {
            MLogin(userName, password);
        } else {
            $("#loginBtn").text("登录");
            $("#errorText").html(data.Message);
        }
    }
});
```

注意这个两句话：crossDomain: true,xhrFields: {withCredentials: true}

**六：安全隐患**

 如果程序猿偷懒将Access-Control-Allow-Origin设置为：Access-Control-Allow-Origin: * 允许任何来自任意域的跨域请求，那么久存在被 DDoS攻击的可能。



### 原型和构造函数

- 原型是function对象的一个属性，该属性是一个对象

- 原型是本身就存在的

  - 原型对象中有默认有两个属性，一个是constructor，该属性指向基于该原型的实例的构造函数，
  - 另一个属性是隐式属性  `__proto`__

- **绝大多数对象**的原型最终都指向Object，除了特殊创建的无原型对象，如下

- ```javascript
  var obj = Object.create(null);
  ```

  **该方法创建出来的对象无原型，并且如果后期为其指定 `__proto`__属性,不会拥有继承特性！！**

  null 和undefined是没有原型的

  tip：null为空对象指针，真正的空对象，{ }也是空的对象，但是还有原型属性


#### prototype的应用：

1.用于提取共有属性

当我们使用构造函数创建属性时，如果出现重复的属性应该用原型来创建，可以减少代码量和冗余，即重复多次使用的属性应该用原型指配，构造函数用来指配特定的对象

#### 原型的增删改查

只能直接对原型进行操作才能成功，否则相当于直接对实例进行添加或修改

**特殊情况：引用值属性**

对于存在于父链上的引用值，如果进行增加可以使父链上的引用值本身发生变化，因为从子链上进行引用值取用，相当于直接对引用值本身进行操作



# 网络基础

#### 关于TCP的三次握手四次挥手

SYN：握手建立信号

ACK：应答同意信号

FIN：挥手信号（断开连接信号)

seq：包的序列号用于分割发送时判断怎么合并

ack：确认号，发送包的序列号

###### tip:SYN攻击

SYN攻击就是在客户端发送SYN信号给服务器端建立连接，但是还未收到服务器端的答复时，被黑客伪造请求发送**随机IP**的SYN请求给服务器，造成服务器的请求队列爆满，使正常的SYN信号无法送达，从而使服务器崩溃瘫痪的攻击。

当出现大量的半连接状态时，且源IP地址是随机的，基本可以判断收到了SYN攻击

解决办法：一类是通过防火墙、路由器等过滤网关防护，另一类是通过加固TCP/IP协议栈防范.但必须清楚的是，SYN攻击不能完全被阻止，我们所做的是尽可能的减轻SYN攻击的危害，除非将TCP协议重新设计。

# 计算机基础

## 缓存相关（非常重要）



#### cache替换策略

FIFO算法 ：先进先出算法

（好！）LRU算法 :最近最久未使用算法