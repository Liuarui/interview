# CSS3

 [CSS3.0 帮助文档.chm](CSS3.0 帮助文档.chm) 

注意：CSS3不支持IE6，7，8。兼容性

### 一、flex弹性布局：

<参考资料：http://www.runoob.com/w3cnote/flex-grammar.html>

**兼容性问题:**Webkit内核的浏览器，必须加上-webkit前缀。

```css
.box{
  display: -webkit-flex; /* Safari */
  display: flex;
}
```

**注意**：设为Flex布局以后，**子元素**的float、clear和vertical-align属性将失效。

##### 1.基本概念

采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。

主轴：橫                  交叉轴：竖

##### **2.容器具有的属性**

###### **flex-direction**

**决定主轴的方向（项目的排列方向）**

- row（默认值）：主轴为水平方向，起点在左端。
- row-reverse：主轴为水平方向，起点在右端。
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿。

###### **flex-wrap**

**定义如果一条轴线排不下，如何换行。**

- nowrap（默认值） ：不换行（**会把项目压缩**）
-  wrap  ：换行
- wrap-reverse： 换行，第一行在下面

###### **flex-flow**

**属性和flex-wrap属性的简写形式**

```css
.box {
  flex-flow: flex-direction flex-wrap;
}
```

###### **justify-content**

**项目在主轴上的对齐方式。**

- flex-start（默认值）：左对齐
- flex-end：右对齐
- center： 居中
- space-between：两端对齐，项目之间的间隔都相等。
- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

###### **align-items**

**定义项目在交叉轴上如何对齐**

- flex-start：交叉轴的起点对齐。
- flex-end：交叉轴的终点对齐。
- center：交叉轴的中点对齐。
- baseline: 项目的第一行文字的基线对齐。
- stretch（**默认值**）：如果项目未设置高度或设为auto，将占满整个容器的高度。

###### **align-conten**

定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

##### 3.项目具有的属性****

1. order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。

2. flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

3. flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

4. flex-basis：

   定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。

   设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

5. **flex：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。**

6. align-self：允许单个项目有与其他项目不一样的对齐方式，**可覆盖align-items属性**。默认值为**auto**，**表示继承父元素的align-items属性**，如果没有父元素，则等同于stretc

   该属性可取6个值，除了auto，其他都与align-items属性完全一致。

   ``` css
   .item {
     align-self: auto | flex-start | flex-end | center | baseline | stretch;
   }
   ```

### 二、transtion：过渡

语法格式:

```
transition: 要过渡的属性  花费时间  运动曲线  何时开始;
```

| 属性                       | 描述                                         | CSS  |
| :------------------------- | -------------------------------------------- | ---- |
| transition                 | 简写属性，用于在一个属性中设置四个过渡属性。 | 3    |
| transition-property        | 规定应用过渡的 CSS 属性的名称。              | 3    |
| transition-duration        | 定义过渡效果花费的时间。默认是 0。           | 3    |
| transition-timing-function | 规定过渡效果的时间曲线。默认是 "ease"。      | 3    |
| transition-delay           | 规定过渡效果何时开始。默认是 0。             | 3    |

运动曲线示意图：

![transition](C:\Users\92530\Desktop\面试复习\images\transition.png)

```css
img {
  width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%;
  transition:transform 0.5s ease-in 0s;
}
img:hover {
  transform:rotate(180deg);
}
```

### 三、@media

针对不同媒体类型（或者说屏幕宽度）自适应采用不同的样式规则。当你重置浏览器大小的过程中，页面会根据浏览器的宽度和高度重新渲染页面。

用于响应式布局，根据设备屏幕不同

使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。

@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。

当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面

### 四、栅格原理（col-xs-12）：

响应式开发



![col-xs-12](C:\Users\92530\Desktop\面试复习\images\col-xs-12.png)

### 五、垂直水平居中

1.水平居中

脱离文档流

- margin：o auto；
- 负margin法：先left：50%，然后在给一个负margin-left居中元素宽度的一半
- transform： translateX：-50%
- 给父容器设置text-align :center, 然后给子容器加上display：inline-block;

2.垂直居中

脱离文档流

- margin： auto 0；
- 负margin法：先top：50%，然后在给一个负margin-top居中元素宽度的一半
- transform： translateY：-50%

3.table-cell法 和flex弹性盒子法

table-cell法（对低版本IE兼容比较良好）

```css
div {
    display: table-cell;
    width: 200px;
    height: 200px;
    text-align: center;
    vertical-align: middle;
}
```

flex法：

``` css
.container{
width: 300px;
height: 200px;
display: -webkit-flex;        //兼容weikit
display: flex;
-webkit-align-items: center;  //兼容weikit
align-items: center;
-webkit-justify-content: center;   //兼容weikit
justify-content: center;
}
```

### 六、三角形画法

从底向上

``` css
#triangle-up {
    width: 0;
    height: 0;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
    border-bottom：100px solid red;
}
```

transparent属性相当于rgba（0,0,0,0,）全透明的颜色

### 七、清除浮动的方法

- BFC消除浮动法：给父盒子加上overflow：hidden；

 	优点：  代码简洁

​	缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。

- 额外标签法：在浮动元素末尾添加一个空的标签例如 <div style="clear:both"></div>，或则其他标签br等亦可。

​    优点： 通俗易懂，书写方便

​    缺点： 添加许多无意义的标签，结构化较差。

- 使用after伪元素清除浮动（推荐）

- ```css 
   .clearfix:after {  content: "."; display: block; height: 0; clear: both; visibility: hidden;  }   
  
   .clearfix {*zoom: 1;}   /* IE6、7 专有 */
  ```

  

- 优点： 符合闭合浮动思想  **结构语义化正确**

  缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。

  ## 八、background属性详解

  

## JS

### 原型和构造函数

- 原型是function对象的一个属性，该属性是一个对象

- 原型是本身就存在的

  - 原型对象中有默认有两个属性，一个是constructor，该属性指向基于该原型的实例的构造函数，
  - 另一个属性是隐式属性  `__proto`__

- **绝大多数对象**的原型最终都指向Object，除了特殊创建的无原型对象，如下

- ```javascript
  var obj = Object.create(null);
  ```

  **该方法创建出来的对象无原型，并且如果后期为其指定 `__proto`__属性,不会拥有继承特性！！**

  null 和undefined是没有原型的

  tip：null为空对象指针，真正的空对象，{ }也是空的对象，但是还有原型属性

  



#### prototype的应用：

1.用于提取共有属性

当我们使用构造函数创建属性时，如果出现重复的属性应该用原型来创建，可以减少代码量和冗余，即重复多次使用的属性应该用原型指配，构造函数用来指配特定的对象

#### 原型的增删改查

只能直接对原型进行操作才能成功，否则相当于直接对实例进行添加或修改

**特殊情况：引用值属性**

对于存在于父链上的引用值，如果进行增加可以使父链上的引用值本身发生变化，因为从子链上进行引用值取用，相当于直接对引用值本身进行操作

# 网络基础

#### 关于TCP的三次握手四次挥手

SYN：握手建立信号

ACK：应答同意信号

FIN：挥手信号（断开连接信号)

seq：包的序列号用于分割发送时判断怎么合并

ack：确认号，发送包的序列号

###### SYN攻击